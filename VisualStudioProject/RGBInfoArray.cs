// Viewer of testbench data generated by
// library for course A0B35SPS - Structures of Computers System
// CTU-FFE Prague, Czech Republic 
// Department of Control Eng. 
// Author: Richard Susta
// Published under GNU General Public License
////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Xml.Linq;
using FpgaLcdUtils;
using System.Data;
using System.Diagnostics;
using System.Data.Common;

/// <summary>
/// Information about VGA pixels
/// </summary>
public class RGBInfoArray
{
  //Width and height of full VGA frame for screen resolution 640x480
  private const int WIDTH_LCD = 1024;
  private const int HEIGHT_LCD = 525;
  public const int VISIBLE_WIDTH_LCD = 800;
  public const int VISIBLE_HEIGHT_LCD = 480;
  // Frame
  public const int BORDER_AROUND = 5; // We add border around of image for its better visibility
                                       //Sizes of bitmap with image
  public const int WIDTH = WIDTH_LCD + 2 * BORDER_AROUND;
  public const int HEIGHT = HEIGHT_LCD + 2 * BORDER_AROUND;
  public const int WIDTH_VISIBLE = VISIBLE_WIDTH_LCD + 2 * BORDER_AROUND;
  public const int HEIGHT_VISIBLE = VISIBLE_HEIGHT_LCD + 2 * BORDER_AROUND;

  public static bool IsVisibleLCDonly { get { return _isVisibleLCDonly; } }
  private static bool _isVisibleLCDonly = false;
  public static void Assign_IsVisibleLCDonly(bool isVisibleLCDOnly) { _isVisibleLCDonly = isVisibleLCDOnly; }

  // Processing messages
  public delegate void DelegateDoEvents();
  //   private DelegateDoEvents _doEvents;

  public FileDescriptor fileDescriptor = new FileDescriptor();


  private int pixelCount = 0;
  /// <summary>
  ///  The total count of loaded pixels from testbench file
  /// </summary>
  public int Count { get { return pixelCount; } }

  /// <summary>
  ///  The total count of loaded pixels from testbench file
  /// </summary>
  public int FrameIndex { get { return fileDescriptor.FrameIndex; } }


  /// <summary>
  /// Testbench pixel
  /// </summary>
  public struct TB
  {
    // structures are always initialized to 0 of false
    public byte IDXY;
    public byte R, G, B;  //8 bit colors

    private const byte MIMAGE = 8, MDE = 4, MXEND = 2, MYEND = 1, MDXY0 = 0;

    /// <summary>
    /// Set all pixels to black, no image
    /// </summary>
    public void Clear() { IDXY = R = G = B = 0; }

    public TB() { Clear(); }
    public TB(TB org) { this.IDXY = org.IDXY; this.R = org.R; this.G = org.G; this.B = org.B; }
    public TB(UInt32 data) : this((int)data) { }

    public TB(int data)
    {
      byte x = (byte)((data >> 24) & 0xFF);
      this.IDXY = (byte)(x & (MDE | MXEND | MYEND));
      this.R = (byte)((data >> 16) & 0xFF);
      this.G = (byte)((data >> 8) & 0xFF);
      this.B = (byte)(data & 0xFF);
    }

    /// <summary>
    /// set upper bits with LCD control signal MDE (data enable), MXend, MYend
    /// </summary>
    /// <param name="column"></param>
    /// <param name="row"></param>
    /// <returns></returns>
    public TB SetDXY(int column, int row)
    {
      IDXY &= MIMAGE; // Clear other bits
      if (column < VISIBLE_WIDTH_LCD && row < VISIBLE_HEIGHT_LCD) IDXY |= MDE;
      else
      {
        IDXY |= ((column == WIDTH_LCD - 1) ? MXEND : MDXY0);
        if (row == HEIGHT_LCD - 1) IDXY |= MYEND;
      }
      return this;
    }

    public bool IsBlack { get { return R == 0 && B == 0 && G == 0; } }

    public bool Image { get { return (IDXY & MIMAGE) != 0; } }

    public bool DE { get { return (IDXY & MDE) != 0; } }
    public bool XEND { get { return (IDXY & MXEND) != 0; } }
    public bool YEND { get { return (IDXY & MYEND) != 0; } }
    public override string ToString()
    {

      string name = TBColorLookupTable.LookupName(R, G, B);
      if (!String.IsNullOrWhiteSpace(name)) name = ":" + name + " ";
      else
      {
        int foundRGB;
        name = TBColorLookupTable.ToNearestNamedColor(R, G, B, out foundRGB);
        if (!String.IsNullOrWhiteSpace(name))
        {
          name = ": near " + name;
        }
      }
      string xx = DE ? "[DE='1']"
                  : String.Format("[DE='0',XEND='{0}', YEND='{1}']", XEND ? 0 : 1, YEND ? 0 : 1);
      return String.Format("0x{0:x2}{1:x2}{2:x2} ({0},{1},{2}{3}) {4}", R, G, B, name, xx);
    }

    public string ToStringReduced()
    {

      string name = TBColorLookupTable.LookupName(R, G, B);
      if (!String.IsNullOrWhiteSpace(name)) name = ":" + name + " ";
      else
      {
        int foundRGB;
        name = TBColorLookupTable.ToNearestNamedColor(R, G, B, out foundRGB);
        if (!String.IsNullOrWhiteSpace(name))
        {
          name = ": near " + name;
        }
      }
      return String.Format("0x{0:x2}{1:x2}{2:x2} ({0},{1},{2}{3})", R, G, B, name);

    }

    public void VerboseColorInfo(ref StringBuilder sb)
    {
      sb.AppendFormat("Color: 0x{0:x2}{1:x2}{2:x2} = RGB({0},{1},{2}) ", R, G, B);
      string name = TBColorLookupTable.LookupName(R, G, B);
      if (!String.IsNullOrWhiteSpace(name))
      { sb.Append("Named color: "); sb.AppendLine(name); }
      else
      {
        int foundRGB;
        name = TBColorLookupTable.ToNearestNamedColor(R, G, B, out foundRGB);
        if (!String.IsNullOrWhiteSpace(name))
        {
          sb.AppendFormat("\r\nThe nearest named color: {0} {1:x6} = RGB({2},{3},{4})", name, foundRGB,
              (foundRGB >> 16) & 0xFF, (foundRGB >> 8) & 0xFF, foundRGB & 0xFF);
        }
      }
    }

    public Color ToColor()
    {
      return IsBlack ?  Color.Black : Color.FromArgb(R, G, B);
    }
  }


  /// <summary>
  /// VGA pixel array
  /// </summary>
  private readonly TB[,] _rgbArray = new TB[WIDTH_LCD, HEIGHT_LCD];

  public readonly TB TBZERO = new TB();
  /// <summary>
  /// Test if bitmapColumn,bitmapRow index is in VGA image 
  /// </summary>
  /// <param name="column"></param>
  /// <param name="row"></param>
  /// <returns></returns>
  public static bool IsLCDImageIndex(int column, int row)
  {
    return (column >= 0 && column < WIDTH_LCD
        && row >= 0 && row < HEIGHT_LCD);
  }

  /// <summary>
  /// Test if bitmapColumn,bitmapRow index is in VGA image 
  /// </summary>
  /// <param name="column"></param>
  /// <param name="row"></param>
  /// <returns></returns>
  public static bool IsLCDVisibleIndex(int column, int row)
  {
    return (column >= 0 && column < VISIBLE_WIDTH_LCD
        && row >= 0 && row < VISIBLE_HEIGHT_LCD);
  }

  /// <summary>
  /// Reverse value shift by border size
  /// </summary>
  /// <param name="pos"></param>
  /// <returns>shifted </returns>
  public static int Index2LCDImage(int pos) { return pos - BORDER_AROUND; }

  /// <summary>
  /// Reverse value shift by border size
  /// </summary>
  /// <param name="pos"></param>
  /// <returns>shifted value</returns>
  public static float Index2LCDImage(float pos) { return pos - BORDER_AROUND; }

  /// <summary>
  /// Get value of VGA image pixel or null if indexes out of VGA image
  /// </summary>
  /// <param name="column">bitmapColumn-x coordinate</param>
  /// <param name="row">bitmapRow-y coordinate</param>
  /// <returns>TB information about loaded pixel values</returns>
  public TB this[int column, int row]
  {
    get
    {
      if (IsVisibleLCDonly)
      {
        if (IsLCDVisibleIndex(column, row))
        {
          TB tb = _rgbArray[column, row];
          tb = tb.SetDXY(column, row);
          return tb;
        }
        else
        {
          TB tb = TBZERO;
          if (IsLCDImageIndex(column, row))
          {
            tb = tb.SetDXY(column, row);
          }
          return tb;
        };

      }
      else
      {
        if (IsLCDImageIndex(column, row))
        {
          TB tb = _rgbArray[column, row];
          tb = tb.SetDXY(column, row);
          return tb;
        }
        else
        {
          return TBZERO;
        };
      }
    }
  }

  /// <summary>
  /// Reload previously loaded testbench file
  /// </summary>
  /// <returns></returns>
  public string Reload(bool fullFrame)
  {
    DateTime lastAccess = DateTime.MinValue;
    return LoadFromFile(fileDescriptor.FileName, -1, fullFrame);
  }

  public string LoadFromBitmap(Bitmap openedBitmap)
  {
    return LoadFromBitmap(openedBitmap, true);
  }

    /// <summary>
    /// Load test bench file
    /// </summary>
    /// <param name="fileName">filename of stored testbench</param>
    /// <returns></returns>
    /// 

    public string LoadFromBitmap(Bitmap openedBitmap, bool isTestbenchViewer)
  {
    bool cropped = false;
    pixelCount = 0;

    if (openedBitmap == null)
      throw new ArgumentNullException("RGBInfoArray.LoadFromBitmap(..) expect not null Bitmap parameters");
    int width = openedBitmap.Width, height = openedBitmap.Height;
    if (isTestbenchViewer)
    {
      if (width > WIDTH_LCD) { cropped = true; width = WIDTH_LCD; }
      if (height > HEIGHT_LCD) { cropped = true; height = RGBInfoArray.HEIGHT_LCD; }
    }
    else
    {
      if (width > VISIBLE_WIDTH_LCD) { cropped = true; width = VISIBLE_WIDTH_LCD; }
      if (height > VISIBLE_HEIGHT_LCD) { cropped = true; height = VISIBLE_HEIGHT_LCD; }
    }

    Array.Clear(_rgbArray, 0, _rgbArray.Length);
    int count = 0;

    for (int x = 0; x < width; x++) // bitmaps are internally stored by rows
    {
      for (int y = 0; y < height; y++)
      {
        _rgbArray[x, y] = new TB(Color2Byte.ToUColor(openedBitmap.GetPixel(x, y))); count++;
      }
    }
    this.pixelCount = count;

    if (isTestbenchViewer)
      return cropped ? String.Format("Loaded whole W*H={0} * {1} = {2} pixels", width, height, count)
                  : String.Format("Loaded fragment W*H={0} * {1}={2} pixels from {3} * {4} bitmap",
                                   width, height, count, openedBitmap.Width, openedBitmap.Height);
    else
    {
      if (openedBitmap.Width > width || openedBitmap.Height > height)
       return String.Format("The canvas is 800x480 px: loaded only W*H={0} * {1}={2} pixels from {3} * {4} bitmap",
          width, height, count, openedBitmap.Width, openedBitmap.Height);
      else return String.Format("Loaded W*H={0} * {1} = {2} pixels", width, height, count);
    }

  }


  public string LoadFromFile(string fileName, int frameIndex, bool wait4CompleteFrame)
  {
    try
    {
      pixelCount = 0;
      byte[] data = TBFileLoader.LoadFile(fileName, wait4CompleteFrame, ref frameIndex, out fileDescriptor);

      bool fileCorrupted = false;
      // Reading loaded data
      using (MemoryStream rdtxt = new MemoryStream(data, 0, fileDescriptor.DataLength))
      {
        if (fileDescriptor.DataLength > 0) rdtxt.Seek(fileDescriptor.StartPos, SeekOrigin.Begin);
        TextReader rd = new StreamReader(rdtxt, ASCIIEncoding.ASCII);
        string line = String.Empty;
        bool isend = false; // null line was read
        Regex rxnum = new Regex(@"\D*(\d+)\D+(\d+)", RegexOptions.Compiled);
        Regex rxrep = new Regex(@"\D*(\d+)", RegexOptions.Compiled);
        // Read pixel information
        int row = 0;
        TB tbdata = new TB(); pixelCount = 0;
        while (row < HEIGHT_LCD && line != null)
        {
          int column = 0;
          while (column < WIDTH_LCD && !isend)
          {
            line = rd.ReadLine(); if (line == null) break;
            if (column == 574)
            { }

            if (line.Length == 0) continue; // empty line

            if (line[0] == '*')
            {
              if (line.Length == 1)
              {

                _rgbArray[column++, row] = tbdata; pixelCount++; // repeat previous value onetimes
              }
              else
              {
                Match rm = rxrep.Match(line);
                int rep = 0;
                if (rm.Success) { rep = int.Parse(rm.Groups[1].Value); }
                for (int irep = 0; irep < rep && column < WIDTH_LCD; irep++)
                {
                  _rgbArray[column++, row] = tbdata; pixelCount++;
                }

              }
              continue;
            }

            if (line.StartsWith("##=")) // ##=bitmapColumn, bitmapRow information
            {
              Match m = rxnum.Match(line);
              if (m.Groups.Count < 3)  // unknown format
              {
                fileCorrupted = true; continue; // read next line
              }
              // Values of pixel coordinates for checking correctness of file
              int colnew = int.Parse(m.Groups[1].Value);
              int rownew = int.Parse(m.Groups[2].Value);
              if (colnew == 0 && rownew== 0) // new frame
              { column = 0; row = 0; }
              if (colnew == column && rownew == row)
              {
                continue; // File is OK
              }
              if (colnew >= WIDTH_LCD || rownew >= HEIGHT_LCD)
              {
                fileCorrupted = true; // invalid numbers
                continue;
              };
              // A part of the file is missing, we fill it by black color
              if (colnew > column || rownew > row)
              {
                while (colnew > column || rownew > row)
                {
                  _rgbArray[column++, row] = TBZERO;
                  if (column >= WIDTH_LCD)
                  {
                    column = 0; row++;
                    if (row >= HEIGHT_LCD)
                      goto EndOfRead;
                  }
                }

              }
              else
              {   // a number is less, i.e. jumb back
                fileCorrupted = true;
              }
              continue;

            }
            if (line.StartsWith("## ")) continue; // comment
                                                  // storing pixel information
            int rgb;
            if (int.TryParse(line, out rgb))
            {
              tbdata = new TB(rgb);
            }
            else
            {
              tbdata = new TB();
            }
            _rgbArray[column++, row] = tbdata; pixelCount++;

          } // while bitmapColumn
          row++;
        } //while bitmapRow
          //     if (_doEvents != null && bitmapRow % 32 == 0) _doEvents();

      } // using
    EndOfRead:
      //RGBInfoArray rgbNew = ApplyFilter(new int[] { 1, 2, 1, 2, 4, 2, 1, 2, 1 }); // Gauss
      //                                                                            //RGBInfoArray rgbNew = ApplyFilter(new int[] { -1, -1, -1, -1, 8, -1, -1, -1, -1 }); // edges
      //                                                                            // RGBInfoArray rgbNew = ApplyFilter(new int[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 }); // motion
      //                                                                            //RGBInfoArray rgbNew = ApplyFilter(new int[] { -1, -1, 0, -1, 0, 1, 0, 1, 1 }); // embos
      //                                                                            // RGBInfoArray rgbNew = ApplyFilter(new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1 }); // mean
      //Array.Copy(rgbNew._rgbArray, _rgbArray, _rgbArray.Length);

      if (!fileCorrupted) TBFileLoader.SetFull(frameIndex);
      string acount = pixelCount == HEIGHT_LCD * WIDTH_LCD ? "all =1024*525 "
                      : ((100.0 * pixelCount) / (HEIGHT_LCD * WIDTH_LCD)).ToString("0.#") + " % ";
      return String.Format("Loaded {0} pixels from file {1} {2}",
                  acount,
                  fileDescriptor.FileName, fileCorrupted ? " with ERRORS: data corrupted by unknown lines" : "");
    }
    catch (Exception ex)
    {
      return ex.Message;
    }
  }
  /// <summary>
  /// Create bitmap from  image
  /// </summary>
  /// <param name="isScreenBitmap">Create with border for screen </param>
  /// <param name="nonBlack">count of non Black pixels</param>
  /// <returns>CreatedBitmap</returns>
  public Bitmap CreateBitmap(bool isScreenBitmap, out int nonBlack)
  {
    return CreateBitmap(isScreenBitmap, true, out nonBlack);
  }

    /// <summary>
    /// Create bitmap from  image
    /// </summary>
    /// <param name="isScreenBitmap">Create with border for screen </param>
    /// <param name="plusDE_ENDS">Mark by RED color X,Y_ENDS</param>
    /// <param name="nonBlack">count of non Black pixels</param>
    /// <returns>CreatedBitmap</returns>
    public Bitmap CreateBitmap(bool isScreenBitmap, bool plusDE_ENDS, out int nonBlack)
  {
    Bitmap bitmap = isScreenBitmap ? new Bitmap(WIDTH, HEIGHT, System.Drawing.Imaging.PixelFormat.Format24bppRgb)
        : new Bitmap(WIDTH_LCD, HEIGHT_LCD, System.Drawing.Imaging.PixelFormat.Format24bppRgb);
    bool de = false, xend = false, yend = false;
    int _nonBlack = 0;
    using (Graphics g = Graphics.FromImage(bitmap))
    {
      for (int bitmapRow = 0; bitmapRow < bitmap.Height; bitmapRow++)
      {
        int row = isScreenBitmap ? bitmapRow - BORDER_AROUND : bitmapRow;
        de = (row >= 0 && row < VISIBLE_HEIGHT_LCD); yend = (row == HEIGHT_LCD);
        for (int bitmapColumn = 0; bitmapColumn < bitmap.Width; bitmapColumn++)
        {
          int column = isScreenBitmap ? bitmapColumn - BORDER_AROUND : bitmapColumn;
          xend = (column == WIDTH_LCD); de = de && (column >= 0 && column < VISIBLE_WIDTH_LCD);
          RGBInfoArray.TB tb = this[column, row]; if(!tb.IsBlack) _nonBlack++;
          Color col = tb.ToColor();
          if (plusDE_ENDS)
          {
            if (xend) col = Color.Red;
            if (yend) col = xend ? Color.Orange : Color.DarkOrange;
          }
          bitmap.SetPixel(bitmapColumn, bitmapRow, col);
        }
        //  if (_doEvents != null && bitmapRow % 32 == 0) _doEvents();
      }
      nonBlack =_nonBlack;
      return bitmap;
    }
  }

  /// <summary>
  /// Create bitmap from VGA image
  /// </summary>
  /// <param name="isScreenBitmap">Create with border for screen </param>
  /// <param name="g">Graphics of device</param>
  /// <param name="isDE">AddNoRepeat blank synchronization puls</param>
  /// <param name="isXEND">AddNoRepeat vertical synchronization puls</param>
  /// <param name="isYEND">AddNoRepeat horizontal synchronization puls</param>
  /// <returns>CreatedBitmap</returns>
  public Bitmap CreateBitmap(bool isScreenBitmap, Graphics g, DelegateDoEvents doEvents)
  {
    Bitmap bitmap = isScreenBitmap ? new Bitmap(WIDTH, HEIGHT, g)
        : new Bitmap(WIDTH_LCD, HEIGHT_LCD, g);
    bool de = false, xend = false, yend = false;
    for (int bitmapRow = 0; bitmapRow < bitmap.Height; bitmapRow++)
    {
      int row = isScreenBitmap ? bitmapRow - BORDER_AROUND : bitmapRow;
      de = (row >= 0 && row < VISIBLE_HEIGHT_LCD); yend = (row == HEIGHT_LCD);
      if (bitmapRow % 32 == 31 && doEvents != null) doEvents();
      for (int bitmapColumn = 0; bitmapColumn < bitmap.Width; bitmapColumn++)
      {
        int column = isScreenBitmap ? bitmapColumn - BORDER_AROUND : bitmapColumn;
        xend = column == WIDTH_LCD; de = de && (column >= 0 && column < VISIBLE_WIDTH_LCD);
        RGBInfoArray.TB tb = this[column, row];
        Color col = tb.ToColor();
        if (xend) col = Color.DarkRed;
        if (yend) col = xend ? Color.Orange : Color.DarkOrange;
        bitmap.SetPixel(bitmapColumn, bitmapRow, col);
      }
      //  if (_doEvents != null && bitmapRow % 32 == 0) _doEvents();
    }
    return bitmap;
  }


  /// <summary>
  /// Create bitmap from LCD image
  /// </summary>
  /// <param name="g">Graphics of device</param>
  /// <returns>Created Bitmap</returns>
  public Bitmap CreateVisibleBitmap(Graphics g, DelegateDoEvents doEvents)
  {
    Bitmap bitmap = new Bitmap(VISIBLE_WIDTH_LCD, VISIBLE_HEIGHT_LCD, g);
    for (int bitmapRow = 0; bitmapRow < bitmap.Height; bitmapRow++)
    {
      int row = bitmapRow;
      if (bitmapRow % 32 == 31 && doEvents != null) doEvents();
      for (int bitmapColumn = 0; bitmapColumn < bitmap.Width; bitmapColumn++)
      {
        int column = bitmapColumn;
        RGBInfoArray.TB tb = this[column, row];
        Color col = tb.ToColor();
        bitmap.SetPixel(bitmapColumn, bitmapRow, col);
      }
      //  if (_doEvents != null && bitmapRow % 32 == 0) _doEvents();
    }
    return bitmap;
  }

  /// <summary>
  /// Initialize array
  /// </summary>
  /// <param name="doEvents">Application.DoEvents() method</param>
  public RGBInfoArray(/*DelegateDoEvents doEvents*/)
  {
    //    this._doEvents = doEvents;
    for (int row = 0; row < HEIGHT_LCD; row++)
      for (int column = 0; column < WIDTH_LCD; column++)
      {
        _rgbArray[column, row] = new TB();
      }
  }

  public RGBInfoArray ApplyFilter(int[] Coef)
  {
    int[,] f = new int[3, 3];
    TB tb0 = new TB(); int divFactor = 0;
    for (int fx = 0; fx <= 2; fx++)
    {
      for (int fy = 0; fy <= 2; fy++)
      { int c = Coef[3 * fy + fx]; f[fx, fy] = c; divFactor += c; }
    }
    if (divFactor == 0) divFactor = 1;
    RGBInfoArray result = new RGBInfoArray();
    for (int ix = 0; ix < 640; ix++)
    {
      for (int jy = 0; jy < 480; jy++)
      {
        int R = 0, G = 0, B = 0;
        for (int fx = 0; fx <= 2; fx++)
        {
          for (int fy = 0; fy <= 2; fy++)
          {
            int x = ix + fx - 1, y = jy + fy - 1;
            TB tb = x >= 0 && x < WIDTH_LCD && y >= 0 && y < HEIGHT_LCD ? _rgbArray[x, y] : tb0;
            int fc = f[fx, fy];
            R += tb.R * fc; G += tb.G * fc; B += tb.B * fc;
          }
        }
        TB tr = result._rgbArray[ix, jy];
        R = (R / divFactor); G = (G / divFactor); B = (B / divFactor);
        if (R < 0) R = 0; else { if (R > 1023) R = 1023; }
        if (G < 0) G = 0; else { if (G > 1023) G = 1023; }
        if (B < 0) B = 0; else { if (B > 1023) B = 1023; }
        tr.R = (byte)R; tr.G = (byte)G; tr.B = (byte)B;
      }
    }
    return result;
  }


}
